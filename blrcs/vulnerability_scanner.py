# BLRCS Vulnerability Scanner
# Comprehensive security vulnerability detection and assessment
import os
import sys
import subprocess
import json
import re
import hashlib
import time
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Set, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from collections import defaultdict
import socket
import ssl
import requests
import tempfile

class VulnerabilityType(Enum):
    """Types of vulnerabilities"""
    CONFIGURATION = "configuration"
    DEPENDENCY = "dependency"
    CODE = "code"
    NETWORK = "network"
    CRYPTOGRAPHIC = "cryptographic"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    DATA_EXPOSURE = "data_exposure"
    INJECTION = "injection"
    SYSTEM = "system"
    COMPLIANCE = "compliance"

class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class VulnerabilityStatus(Enum):
    """Vulnerability status"""
    OPEN = "open"
    ACKNOWLEDGED = "acknowledged"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    FALSE_POSITIVE = "false_positive"
    ACCEPTED_RISK = "accepted_risk"

@dataclass
class Vulnerability:
    """Vulnerability finding"""
    id: str
    title: str
    description: str
    severity: SeverityLevel
    vulnerability_type: VulnerabilityType
    affected_component: str
    location: str = ""
    line_number: Optional[int] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    evidence: List[str] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=datetime.now)
    status: VulnerabilityStatus = VulnerabilityStatus.OPEN
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if isinstance(self.severity, str):
            self.severity = SeverityLevel(self.severity)
        if isinstance(self.vulnerability_type, str):
            self.vulnerability_type = VulnerabilityType(self.vulnerability_type)
        if isinstance(self.status, str):
            self.status = VulnerabilityStatus(self.status)
        if isinstance(self.discovered_at, str):
            self.discovered_at = datetime.fromisoformat(self.discovered_at)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value,
            'vulnerability_type': self.vulnerability_type.value,
            'affected_component': self.affected_component,
            'location': self.location,
            'line_number': self.line_number,
            'cwe_id': self.cwe_id,
            'cvss_score': self.cvss_score,
            'evidence': self.evidence,
            'recommendations': self.recommendations,
            'references': self.references,
            'discovered_at': self.discovered_at.isoformat(),
            'status': self.status.value,
            'metadata': self.metadata
        }
    
    def calculate_risk_score(self) -> float:
        """Calculate risk score based on severity and other factors"""
        base_scores = {
            SeverityLevel.INFO: 0.0,
            SeverityLevel.LOW: 2.5,
            SeverityLevel.MEDIUM: 5.0,
            SeverityLevel.HIGH: 7.5,
            SeverityLevel.CRITICAL: 10.0
        }
        
        score = base_scores.get(self.severity, 5.0)
        
        # Adjust based on CVSS score if available
        if self.cvss_score:
            score = max(score, self.cvss_score)
        
        # Adjust based on component criticality
        critical_components = ['auth', 'security', 'encryption', 'database']
        if any(comp in self.affected_component.lower() for comp in critical_components):
            score *= 1.2
        
        return min(score, 10.0)

@dataclass
class ScanResult:
    """Scan result summary"""
    scan_id: str
    target: str
    scan_type: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    summary: Dict[str, int] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def calculate_summary(self):
        """Calculate vulnerability summary"""
        self.summary = {
            'total': len(self.vulnerabilities),
            'critical': len([v for v in self.vulnerabilities if v.severity == SeverityLevel.CRITICAL]),
            'high': len([v for v in self.vulnerabilities if v.severity == SeverityLevel.HIGH]),
            'medium': len([v for v in self.vulnerabilities if v.severity == SeverityLevel.MEDIUM]),
            'low': len([v for v in self.vulnerabilities if v.severity == SeverityLevel.LOW]),
            'info': len([v for v in self.vulnerabilities if v.severity == SeverityLevel.INFO])
        }
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'scan_id': self.scan_id,
            'target': self.target,
            'scan_type': self.scan_type,
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat() if self.end_time else None,
            'status': self.status,
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            'summary': self.summary,
            'metadata': self.metadata
        }

class ConfigurationScanner:
    """Scans for configuration vulnerabilities"""
    
    def __init__(self):
        self.rules = self._load_config_rules()
    
    def _load_config_rules(self) -> List[Dict[str, Any]]:
        """Load configuration security rules"""
        return [
            {
                'name': 'Debug Mode Enabled',
                'pattern': r'debug\s*=\s*[Tt]rue',
                'file_types': ['.py', '.js', '.json', '.yaml', '.yml'],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Debug mode should be disabled in production',
                'cwe': 'CWE-489'
            },
            {
                'name': 'Default Credentials',
                'pattern': r'(password|pwd|secret)\s*=\s*["\']?(admin|password|123456|default)["\']?',
                'file_types': ['.py', '.js', '.json', '.yaml', '.yml', '.ini', '.conf'],
                'severity': SeverityLevel.HIGH,
                'description': 'Default or weak credentials detected',
                'cwe': 'CWE-798'
            },
            {
                'name': 'Hardcoded API Keys',
                'pattern': r'(api_key|apikey|secret_key)\s*=\s*["\'][a-zA-Z0-9]{20,}["\']',
                'file_types': ['.py', '.js', '.json', '.yaml', '.yml'],
                'severity': SeverityLevel.HIGH,
                'description': 'Hardcoded API key detected',
                'cwe': 'CWE-798'
            },
            {
                'name': 'Weak TLS Configuration',
                'pattern': r'ssl_version\s*=\s*["\']?(TLSv1|SSLv)["\']?',
                'file_types': ['.py', '.js', '.json', '.yaml', '.yml', '.conf'],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Weak TLS/SSL version configuration',
                'cwe': 'CWE-326'
            },
            {
                'name': 'Insecure Random',
                'pattern': r'random\.(randint|random|choice)',
                'file_types': ['.py'],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Use of insecure random number generator',
                'cwe': 'CWE-338'
            },
            {
                'name': 'SQL Injection Risk',
                'pattern': r'execute\(["\'][^"\']*%[^"\']*["\']',
                'file_types': ['.py'],
                'severity': SeverityLevel.HIGH,
                'description': 'Potential SQL injection vulnerability',
                'cwe': 'CWE-89'
            },
            {
                'name': 'Path Traversal Risk',
                'pattern': r'open\([^)]*\+[^)]*\)',
                'file_types': ['.py'],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Potential path traversal vulnerability',
                'cwe': 'CWE-22'
            },
            {
                'name': 'Insecure Deserialization',
                'pattern': r'pickle\.loads?\(',
                'file_types': ['.py'],
                'severity': SeverityLevel.HIGH,
                'description': 'Use of insecure deserialization',
                'cwe': 'CWE-502'
            }
        ]
    
    def scan_files(self, target_dir: Path) -> List[Vulnerability]:
        """Scan files for configuration vulnerabilities"""
        vulnerabilities = []
        
        for rule in self.rules:
            pattern = re.compile(rule['pattern'], re.IGNORECASE)
            
            for file_path in target_dir.rglob('*'):
                if (file_path.is_file() and 
                    any(file_path.suffix == ext for ext in rule['file_types'])):
                    
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        for line_num, line in enumerate(content.split('\n'), 1):
                            match = pattern.search(line)
                            if match:
                                vuln_id = f"config_{hashlib.sha256(f'{file_path}:{line_num}:{rule["name"]}'.encode()).hexdigest()[:8]}"
                                
                                vulnerability = Vulnerability(
                                    id=vuln_id,
                                    title=rule['name'],
                                    description=rule['description'],
                                    severity=rule['severity'],
                                    vulnerability_type=VulnerabilityType.CONFIGURATION,
                                    affected_component=str(file_path),
                                    location=str(file_path),
                                    line_number=line_num,
                                    cwe_id=rule.get('cwe'),
                                    evidence=[line.strip()],
                                    recommendations=[
                                        f"Review and fix the {rule['name'].lower()} in {file_path}",
                                        "Follow secure coding practices"
                                    ]
                                )
                                
                                vulnerabilities.append(vulnerability)
                    
                    except Exception:
                        continue  # Skip files that can't be read
        
        return vulnerabilities

class DependencyScanner:
    """Scans for vulnerable dependencies"""
    
    def __init__(self):
        self.vulnerability_db = self._load_vulnerability_db()
    
    def _load_vulnerability_db(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load known vulnerability database"""
        # In a real implementation, this would load from CVE databases
        # For now, return some common vulnerable packages
        return {
            'requests': [
                {
                    'version_range': '<2.20.0',
                    'cve': 'CVE-2018-18074',
                    'severity': SeverityLevel.MEDIUM,
                    'description': 'Credentials exposure vulnerability'
                }
            ],
            'pyyaml': [
                {
                    'version_range': '<5.1',
                    'cve': 'CVE-2017-18342',
                    'severity': SeverityLevel.HIGH,
                    'description': 'Arbitrary code execution via yaml.load()'
                }
            ],
            'flask': [
                {
                    'version_range': '<1.0',
                    'cve': 'CVE-2018-1000656',
                    'severity': SeverityLevel.HIGH,
                    'description': 'Denial of service vulnerability'
                }
            ]
        }
    
    def scan_requirements(self, requirements_file: Path) -> List[Vulnerability]:
        """Scan requirements file for vulnerable dependencies"""
        vulnerabilities = []
        
        if not requirements_file.exists():
            return vulnerabilities
        
        try:
            with open(requirements_file, 'r') as f:
                requirements = f.read()
            
            for line in requirements.split('\n'):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                
                # Parse package name and version
                package_info = self._parse_requirement(line)
                if not package_info:
                    continue
                
                package_name, version = package_info
                
                # Check for vulnerabilities
                if package_name.lower() in self.vulnerability_db:
                    for vuln_info in self.vulnerability_db[package_name.lower()]:
                        if self._version_in_range(version, vuln_info['version_range']):
                            vuln_id = f"dep_{hashlib.sha256(f'{package_name}:{version}:{vuln_info["cve"]}'.encode()).hexdigest()[:8]}"
                            
                            vulnerability = Vulnerability(
                                id=vuln_id,
                                title=f"Vulnerable dependency: {package_name}",
                                description=vuln_info['description'],
                                severity=vuln_info['severity'],
                                vulnerability_type=VulnerabilityType.DEPENDENCY,
                                affected_component=package_name,
                                location=str(requirements_file),
                                cwe_id=vuln_info.get('cve'),
                                evidence=[line],
                                recommendations=[
                                    f"Update {package_name} to a version outside the vulnerable range",
                                    "Review release notes for breaking changes",
                                    "Test application after upgrade"
                                ],
                                references=[f"CVE: {vuln_info['cve']}"]
                            )
                            
                            vulnerabilities.append(vulnerability)
        
        except Exception:
            pass  # Skip if can't read requirements
        
        return vulnerabilities
    
    def _parse_requirement(self, line: str) -> Optional[Tuple[str, str]]:
        """Parse requirement line to extract package name and version"""
        # Simple parsing for common patterns
        patterns = [
            r'^([a-zA-Z0-9_-]+)==([0-9.]+)',
            r'^([a-zA-Z0-9_-]+)>=([0-9.]+)',
            r'^([a-zA-Z0-9_-]+)<=([0-9.]+)',
            r'^([a-zA-Z0-9_-]+)>([0-9.]+)',
            r'^([a-zA-Z0-9_-]+)<([0-9.]+)',
            r'^([a-zA-Z0-9_-]+)~=([0-9.]+)',
            r'^([a-zA-Z0-9_-]+)\s*$'  # No version specified
        ]
        
        for pattern in patterns:
            match = re.match(pattern, line)
            if match:
                if len(match.groups()) == 2:
                    return match.group(1), match.group(2)
                else:
                    return match.group(1), "unknown"
        
        return None
    
    def _version_in_range(self, version: str, version_range: str) -> bool:
        """Check if version is in vulnerable range"""
        if version == "unknown":
            return True  # Assume vulnerable if version unknown
        
        # Simple version comparison (in real implementation, use packaging library)
        if version_range.startswith('<'):
            target_version = version_range[1:]
            return self._compare_versions(version, target_version) < 0
        elif version_range.startswith('<='):
            target_version = version_range[2:]
            return self._compare_versions(version, target_version) <= 0
        elif version_range.startswith('>'):
            target_version = version_range[1:]
            return self._compare_versions(version, target_version) > 0
        elif version_range.startswith('>='):
            target_version = version_range[2:]
            return self._compare_versions(version, target_version) >= 0
        elif version_range.startswith('=='):
            target_version = version_range[2:]
            return version == target_version
        
        return False
    
    def _compare_versions(self, v1: str, v2: str) -> int:
        """Compare two version strings"""
        def normalize(v):
            return [int(x) for x in re.sub(r'(\.0+)*$','', v).split(".")]
        
        v1_parts = normalize(v1)
        v2_parts = normalize(v2)
        
        # Pad shorter version with zeros
        max_len = max(len(v1_parts), len(v2_parts))
        v1_parts.extend([0] * (max_len - len(v1_parts)))
        v2_parts.extend([0] * (max_len - len(v2_parts)))
        
        for i in range(max_len):
            if v1_parts[i] < v2_parts[i]:
                return -1
            elif v1_parts[i] > v2_parts[i]:
                return 1
        
        return 0

class NetworkScanner:
    """Scans for network-related vulnerabilities"""
    
    def __init__(self):
        self.timeout = 5
    
    def scan_ports(self, host: str = "localhost", ports: List[int] = None) -> List[Vulnerability]:
        """Scan for open ports and services"""
        if ports is None:
            ports = [21, 22, 23, 25, 53, 80, 110, 443, 993, 995, 8080, 8443]
        
        vulnerabilities = []
        
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                result = sock.connect_ex((host, port))
                sock.close()
                
                if result == 0:  # Port is open
                    service_info = self._identify_service(host, port)
                    
                    # Check for vulnerable services
                    if port in [21, 23]:  # FTP, Telnet
                        vuln_id = f"net_{hashlib.sha256(f'{host}:{port}'.encode()).hexdigest()[:8]}"
                        vulnerability = Vulnerability(
                            id=vuln_id,
                            title=f"Insecure service on port {port}",
                            description=f"Potentially insecure service running on port {port}",
                            severity=SeverityLevel.MEDIUM,
                            vulnerability_type=VulnerabilityType.NETWORK,
                            affected_component=f"{host}:{port}",
                            location=f"{host}:{port}",
                            evidence=[f"Open port: {port}", service_info],
                            recommendations=[
                                "Disable unnecessary services",
                                "Use secure alternatives (SSH instead of Telnet, SFTP instead of FTP)",
                                "Implement proper access controls"
                            ]
                        )
                        vulnerabilities.append(vulnerability)
                    
                    elif port == 80:  # HTTP
                        vuln_id = f"net_{hashlib.sha256(f'{host}:{port}_http'.encode()).hexdigest()[:8]}"
                        vulnerability = Vulnerability(
                            id=vuln_id,
                            title="Unencrypted HTTP service",
                            description="Web service is using unencrypted HTTP",
                            severity=SeverityLevel.LOW,
                            vulnerability_type=VulnerabilityType.NETWORK,
                            affected_component=f"{host}:{port}",
                            location=f"{host}:{port}",
                            evidence=[f"HTTP service on port {port}"],
                            recommendations=[
                                "Use HTTPS instead of HTTP",
                                "Implement HTTP to HTTPS redirects",
                                "Configure proper SSL/TLS certificates"
                            ]
                        )
                        vulnerabilities.append(vulnerability)
            
            except Exception:
                continue
        
        return vulnerabilities
    
    def scan_ssl_configuration(self, host: str, port: int = 443) -> List[Vulnerability]:
        """Scan SSL/TLS configuration"""
        vulnerabilities = []
        
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((host, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    version = ssock.version()
                    
                    # Check for weak protocols
                    if version in ['TLSv1', 'TLSv1.1', 'SSLv2', 'SSLv3']:
                        vuln_id = f"ssl_{hashlib.sha256(f'{host}:{port}_weak_protocol'.encode()).hexdigest()[:8]}"
                        vulnerability = Vulnerability(
                            id=vuln_id,
                            title="Weak SSL/TLS protocol",
                            description=f"Server supports weak protocol: {version}",
                            severity=SeverityLevel.MEDIUM,
                            vulnerability_type=VulnerabilityType.CRYPTOGRAPHIC,
                            affected_component=f"{host}:{port}",
                            location=f"{host}:{port}",
                            evidence=[f"Protocol: {version}"],
                            recommendations=[
                                "Disable weak SSL/TLS protocols",
                                "Use TLS 1.2 or higher",
                                "Update SSL/TLS configuration"
                            ]
                        )
                        vulnerabilities.append(vulnerability)
                    
                    # Check cipher strength
                    if cipher and len(cipher) >= 3:
                        cipher_name = cipher[0]
                        if any(weak in cipher_name for weak in ['RC4', 'DES', 'MD5', 'NULL']):
                            vuln_id = f"ssl_{hashlib.sha256(f'{host}:{port}_weak_cipher'.encode()).hexdigest()[:8]}"
                            vulnerability = Vulnerability(
                                id=vuln_id,
                                title="Weak SSL/TLS cipher",
                                description=f"Server uses weak cipher: {cipher_name}",
                                severity=SeverityLevel.MEDIUM,
                                vulnerability_type=VulnerabilityType.CRYPTOGRAPHIC,
                                affected_component=f"{host}:{port}",
                                location=f"{host}:{port}",
                                evidence=[f"Cipher: {cipher_name}"],
                                recommendations=[
                                    "Disable weak ciphers",
                                    "Use strong cipher suites",
                                    "Update cipher configuration"
                                ]
                            )
                            vulnerabilities.append(vulnerability)
                    
                    # Check certificate
                    if cert:
                        # Check for self-signed certificates
                        if cert.get('issuer') == cert.get('subject'):
                            vuln_id = f"ssl_{hashlib.sha256(f'{host}:{port}_self_signed'.encode()).hexdigest()[:8]}"
                            vulnerability = Vulnerability(
                                id=vuln_id,
                                title="Self-signed SSL certificate",
                                description="Server uses a self-signed certificate",
                                severity=SeverityLevel.LOW,
                                vulnerability_type=VulnerabilityType.CRYPTOGRAPHIC,
                                affected_component=f"{host}:{port}",
                                location=f"{host}:{port}",
                                evidence=["Self-signed certificate"],
                                recommendations=[
                                    "Use a certificate from a trusted CA",
                                    "Implement proper certificate validation",
                                    "Monitor certificate expiration"
                                ]
                            )
                            vulnerabilities.append(vulnerability)
        
        except Exception:
            pass  # SSL service not available or other error
        
        return vulnerabilities
    
    def _identify_service(self, host: str, port: int) -> str:
        """Identify service running on port"""
        service_map = {
            21: "FTP",
            22: "SSH",
            23: "Telnet",
            25: "SMTP",
            53: "DNS",
            80: "HTTP",
            110: "POP3",
            443: "HTTPS",
            993: "IMAPS",
            995: "POP3S",
            8080: "HTTP-Alt",
            8443: "HTTPS-Alt"
        }
        
        return service_map.get(port, f"Unknown service on port {port}")

class VulnerabilityScanner:
    """Main vulnerability scanner"""
    
    def __init__(self, database=None, logger=None):
        self.database = database
        self.logger = logger
        self.config_scanner = ConfigurationScanner()
        self.dependency_scanner = DependencyScanner()
        self.network_scanner = NetworkScanner()
        self.scan_results: Dict[str, ScanResult] = {}
        self.lock = threading.Lock()
    
    def scan_configuration(self, target_dir: Path) -> ScanResult:
        """Scan for configuration vulnerabilities"""
        scan_id = f"config_scan_{int(time.time())}"
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=str(target_dir),
            scan_type="configuration",
            start_time=datetime.now()
        )
        
        try:
            if self.logger:
                self.logger.info(f"Starting configuration scan: {scan_id}")
            
            vulnerabilities = self.config_scanner.scan_files(target_dir)
            
            scan_result.vulnerabilities = vulnerabilities
            scan_result.end_time = datetime.now()
            scan_result.status = "completed"
            scan_result.calculate_summary()
            
            if self.logger:
                self.logger.info(f"Configuration scan completed: {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.metadata['error'] = str(e)
            if self.logger:
                self.logger.error(f"Configuration scan failed: {e}")
        
        with self.lock:
            self.scan_results[scan_id] = scan_result
        
        if self.database:
            self._save_scan_result(scan_result)
        
        return scan_result
    
    def scan_dependencies(self, requirements_file: Path) -> ScanResult:
        """Scan for vulnerable dependencies"""
        scan_id = f"dep_scan_{int(time.time())}"
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=str(requirements_file),
            scan_type="dependencies",
            start_time=datetime.now()
        )
        
        try:
            if self.logger:
                self.logger.info(f"Starting dependency scan: {scan_id}")
            
            vulnerabilities = self.dependency_scanner.scan_requirements(requirements_file)
            
            scan_result.vulnerabilities = vulnerabilities
            scan_result.end_time = datetime.now()
            scan_result.status = "completed"
            scan_result.calculate_summary()
            
            if self.logger:
                self.logger.info(f"Dependency scan completed: {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.metadata['error'] = str(e)
            if self.logger:
                self.logger.error(f"Dependency scan failed: {e}")
        
        with self.lock:
            self.scan_results[scan_id] = scan_result
        
        if self.database:
            self._save_scan_result(scan_result)
        
        return scan_result
    
    def scan_network(self, host: str = "localhost", ports: List[int] = None) -> ScanResult:
        """Scan for network vulnerabilities"""
        scan_id = f"net_scan_{int(time.time())}"
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=host,
            scan_type="network",
            start_time=datetime.now()
        )
        
        try:
            if self.logger:
                self.logger.info(f"Starting network scan: {scan_id}")
            
            vulnerabilities = []
            
            # Port scan
            port_vulns = self.network_scanner.scan_ports(host, ports)
            vulnerabilities.extend(port_vulns)
            
            # SSL scan if HTTPS port is open
            if 443 in (ports or [443]):
                ssl_vulns = self.network_scanner.scan_ssl_configuration(host, 443)
                vulnerabilities.extend(ssl_vulns)
            
            scan_result.vulnerabilities = vulnerabilities
            scan_result.end_time = datetime.now()
            scan_result.status = "completed"
            scan_result.calculate_summary()
            
            if self.logger:
                self.logger.info(f"Network scan completed: {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.metadata['error'] = str(e)
            if self.logger:
                self.logger.error(f"Network scan failed: {e}")
        
        with self.lock:
            self.scan_results[scan_id] = scan_result
        
        if self.database:
            self._save_scan_result(scan_result)
        
        return scan_result
    
    def comprehensive_scan(self, target_dir: Path, host: str = "localhost") -> Dict[str, ScanResult]:
        """Run comprehensive vulnerability scan"""
        scan_results = {}
        
        if self.logger:
            self.logger.info("Starting comprehensive vulnerability scan")
        
        # Configuration scan
        config_result = self.scan_configuration(target_dir)
        scan_results['configuration'] = config_result
        
        # Dependency scan
        requirements_files = [
            target_dir / "requirements.txt",
            target_dir / "requirements-dev.txt",
            target_dir / "setup.py",
            target_dir / "pyproject.toml"
        ]
        
        for req_file in requirements_files:
            if req_file.exists():
                dep_result = self.scan_dependencies(req_file)
                scan_results[f'dependencies_{req_file.name}'] = dep_result
                break
        
        # Network scan
        network_result = self.scan_network(host)
        scan_results['network'] = network_result
        
        if self.logger:
            total_vulns = sum(len(result.vulnerabilities) for result in scan_results.values())
            self.logger.info(f"Comprehensive scan completed: {total_vulns} total vulnerabilities found")
        
        return scan_results
    
    def get_scan_result(self, scan_id: str) -> Optional[ScanResult]:
        """Get scan result by ID"""
        return self.scan_results.get(scan_id)
    
    def get_vulnerability_stats(self) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        all_vulnerabilities = []
        for result in self.scan_results.values():
            all_vulnerabilities.extend(result.vulnerabilities)
        
        stats = {
            'total_scans': len(self.scan_results),
            'total_vulnerabilities': len(all_vulnerabilities),
            'by_severity': defaultdict(int),
            'by_type': defaultdict(int),
            'by_status': defaultdict(int),
            'risk_score': 0.0
        }
        
        total_risk = 0.0
        for vuln in all_vulnerabilities:
            stats['by_severity'][vuln.severity.value] += 1
            stats['by_type'][vuln.vulnerability_type.value] += 1
            stats['by_status'][vuln.status.value] += 1
            total_risk += vuln.calculate_risk_score()
        
        if all_vulnerabilities:
            stats['risk_score'] = total_risk / len(all_vulnerabilities)
        
        return stats
    
    def export_report(self, output_file: Path, format_type: str = 'json') -> bool:
        """Export vulnerability report"""
        try:
            report_data = {
                'generated_at': datetime.now().isoformat(),
                'scanner_version': '1.0.0',
                'summary': self.get_vulnerability_stats(),
                'scan_results': [result.to_dict() for result in self.scan_results.values()]
            }
            
            if format_type == 'json':
                with open(output_file, 'w') as f:
                    json.dump(report_data, f, indent=2)
            
            elif format_type == 'html':
                html_content = self._generate_html_report(report_data)
                with open(output_file, 'w') as f:
                    f.write(html_content)
            
            return True
            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to export report: {e}")
            return False
    
    def _generate_html_report(self, report_data: Dict[str, Any]) -> str:
        """Generate HTML vulnerability report"""
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>BLRCS Vulnerability Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background: #f4f4f4; padding: 20px; border-radius: 5px; }
                .severity-critical { color: #d32f2f; }
                .severity-high { color: #f57c00; }
                .severity-medium { color: #fbc02d; }
                .severity-low { color: #388e3c; }
                .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
                .summary { background: #e3f2fd; padding: 15px; border-radius: 5px; margin: 20px 0; }
                table { width: 100%; border-collapse: collapse; }
                th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>BLRCS Vulnerability Report</h1>
                <p>Generated: {generated_at}</p>
            </div>
            
            <div class="summary">
                <h2>Summary</h2>
                <p>Total Vulnerabilities: {total_vulnerabilities}</p>
                <p>Risk Score: {risk_score:.2f}/10</p>
            </div>
            
            <h2>Vulnerabilities by Severity</h2>
            <table>
                <tr><th>Severity</th><th>Count</th></tr>
                <tr><td class="severity-critical">Critical</td><td>{critical}</td></tr>
                <tr><td class="severity-high">High</td><td>{high}</td></tr>
                <tr><td class="severity-medium">Medium</td><td>{medium}</td></tr>
                <tr><td class="severity-low">Low</td><td>{low}</td></tr>
            </table>
            
            <h2>Detailed Findings</h2>
            {vulnerabilities}
        </body>
        </html>
        """
        
        summary = report_data['summary']
        vulnerabilities_html = ""
        
        for scan_result in report_data['scan_results']:
            for vuln in scan_result['vulnerabilities']:
                vuln_html = f"""
                <div class="vulnerability">
                    <h3 class="severity-{vuln['severity']}">{vuln['title']}</h3>
                    <p><strong>Severity:</strong> {vuln['severity'].title()}</p>
                    <p><strong>Component:</strong> {vuln['affected_component']}</p>
                    <p><strong>Description:</strong> {vuln['description']}</p>
                    <p><strong>Recommendations:</strong></p>
                    <ul>
                        {''.join(f'<li>{rec}</li>' for rec in vuln['recommendations'])}
                    </ul>
                </div>
                """
                vulnerabilities_html += vuln_html
        
        return html_template.format(
            generated_at=report_data['generated_at'],
            total_vulnerabilities=summary['total_vulnerabilities'],
            risk_score=summary['risk_score'],
            critical=summary['by_severity'].get('critical', 0),
            high=summary['by_severity'].get('high', 0),
            medium=summary['by_severity'].get('medium', 0),
            low=summary['by_severity'].get('low', 0),
            vulnerabilities=vulnerabilities_html
        )
    
    def _save_scan_result(self, scan_result: ScanResult):
        """Save scan result to database"""
        if self.database:
            try:
                # Save scan result
                scan_data = scan_result.to_dict()
                self.database.insert('vulnerability_scans', {
                    'scan_id': scan_data['scan_id'],
                    'target': scan_data['target'],
                    'scan_type': scan_data['scan_type'],
                    'start_time': scan_data['start_time'],
                    'end_time': scan_data['end_time'],
                    'status': scan_data['status'],
                    'summary': json.dumps(scan_data['summary']),
                    'metadata': json.dumps(scan_data['metadata'])
                })
                
                # Save vulnerabilities
                for vuln in scan_result.vulnerabilities:
                    vuln_data = vuln.to_dict()
                    vuln_data['scan_id'] = scan_result.scan_id
                    self.database.insert('vulnerabilities', vuln_data)
                    
            except Exception as e:
                if self.logger:
                    self.logger.error(f"Failed to save scan result: {e}")

# Factory function
def create_vulnerability_scanner(database=None, logger=None) -> VulnerabilityScanner:
    """Create vulnerability scanner instance"""
    return VulnerabilityScanner(database, logger)

# Export main classes
__all__ = [
    'VulnerabilityType', 'SeverityLevel', 'VulnerabilityStatus',
    'Vulnerability', 'ScanResult', 'VulnerabilityScanner',
    'ConfigurationScanner', 'DependencyScanner', 'NetworkScanner',
    'create_vulnerability_scanner'
]